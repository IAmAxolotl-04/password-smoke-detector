
Network Working Group                                     IAmAxolotl-04
Internet-Draft                                      Credential Shield Protocol
Intended status: Experimental                         January 2026
Expires: July 2026

           The Credential Shield Protocol (CSP)
      A Privacy-Preserving Password Breach Checking Protocol

# 1. Introduction

## 1.1. Motivation and Background

Credential Shield Protocol (CSP) enables privacy-preserving password breach checking.
Only hash prefixes are exchanged with the server to maintain user privacy.

## 1.2. Protocol Goals

1. Privacy preservation
2. Accurate breach detection
3. Interoperability
4. Deployable in real-world systems

## 1.3. Non-Goals

CSP does NOT:
* Replace password storage
* Replace authentication protocols
* Protect against client-side malware

# 3. Protocol Overview

## 3.1. Core Protocol Flow

1. Client hashes password locally using SHA-512
2. Extracts first N characters (prefix)
3. Sends prefix to server
4. Server returns potential full hashes with matching prefix
5. Client checks locally for full match

## 3.2. Threat Model

- Honest-but-curious server
- Passive network observer
- Client device integrity

CSP does NOT protect against:
- MITM attacks (TLS required)
- Client malware
- Malicious server data

# 4. Protocol Details

## 4.1. Hash Function Requirements
- MUST support SHA-512
- SHOULD support SHA-256 and SHA-384

## 4.2. Prefix Exchange
- Prefix length default: 16 hex chars (64 bits)
- Longer prefixes: fewer false positives
- Shorter prefixes: lower server load

## 4.3. Server-Side Processing
- Indexed breach database
- Return full hashes matching prefix
- Do NOT log or correlate queries

## 4.4. Client-Side Verification
- Compute full hash locally
- Compare against server results
- Verification result never leaves client device

# 5. Security Considerations

- Zero-knowledge design ensures server cannot infer password
- Hash prefixes prevent full credential exposure
- Collisions are extremely unlikely for default prefix length

1.  Introduction

   1.1.  Motivation

   Traditional password breach checking services, while valuable for
   security, introduce privacy concerns by requiring users to submit
   full password hashes to centralized servers. This creates permanent
   query logs that can be analyzed, correlated, and potentially
   compromised.

   The Credential Shield Protocol (CSP) addresses this by implementing
   a zero-knowledge approach where only non-reversible hash prefixes
   are exchanged. The server assists in breach checking without
   learning whether a match was found, preserving user privacy while
   maintaining security utility.

   1.2.  Protocol Overview

   CSP operates on a simple principle: "Check without revealing."
   The protocol follows these steps:

   1.  Client hashes password locally using a strong cryptographic
       hash function (e.g., SHA-512)
   2.  Client extracts the first N characters (prefix) of the hash
   3.  Client sends only the prefix to the server
   4.  Server returns possible full hashes from breach databases
       that share that prefix
   5.  Client checks locally if any returned hash matches the full
       local hash
   6.  Server never learns the verification result

   This approach minimizes data exposure while providing breach
   checking functionality.

2.  Terminology

   This section defines terms used in the CSP specification.

   - **Client:** The entity checking a password for breaches.
   - **Server:** The entity storing breach data and responding to prefix queries.
   - **Prefix:** The first N characters of a cryptographic hash.
   - **Zero-knowledge:** A property ensuring the server cannot deduce the client’s full hash.
   - **Full Hash:** The complete hash of the password (never sent to the server).
   - **Breach Database:** A collection of known compromised password hashes.

3.  Protocol Details

   3.1.  Hashing and Prefix Extraction

   - Clients hash passwords locally using a strong algorithm (e.g., SHA-512).
   - A fixed-length prefix (e.g., 16 hex characters) is extracted for server queries.
   - Prefix length is chosen to balance security and query efficiency.

   3.2.  Server Query

   - Client sends only the prefix to the server.
   - Server returns candidate full hashes that match the prefix.
   - Server does not learn which full hash (if any) is present on the client.

   3.3.  Local Verification

   - Client compares received hashes with its own local full hash.
   - No sensitive data is transmitted during verification.
   - Client determines breach status entirely locally.

4.  Security Considerations

   - Prefix length must be sufficient to prevent collisions and minimize leakage.
   - Servers should rate-limit queries to mitigate enumeration attacks.
   - Full hashes should never leave the client.
   - Consider adding optional salts or HMACs to further strengthen privacy.
   - Ensure TLS is used for all client-server communications.

5.  Test Vectors

   The following JSON artifacts are generated by the CSP hasher for RFC purposes:

   - `docs/rfc/test-vectors.json` : Contains example password inputs and expected hash prefixes.
   - `docs/rfc/protocol-metadata.json` : Contains collision probabilities and protocol metadata.

   Clients and servers may use these vectors to verify correct implementations.
Appendix A. Collision Probability Analysis

Probability of two different passwords producing same N-character prefix:
1 / 2^(4N)

Appendix B. Test Vectors

Machine-readable test vectors are available in:
./appendix-b-test-vectors.json

Appendix C. Reference Implementation

Reference implementation (JavaScript):
https://github.com/IAmAxolotl-04/password-smoke-detector
